C251 COMPILER V5.60.0,  Element                                                            13/03/24  22:32:50  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Element
OBJECT MODULE PLACED IN .\Out_File\Element.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\Element.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\Element.lst) OBJECT(.\Out_File\Element.obj) 

stmt  level    source

    1          #include "isr.h"
    2          #include <string.h>
    3          #include <stdio.h>
    4          #include "common.h"
    5          #include "Element.h"
    6          #include "Motor.h"
    7          #include "PID.h"
    8          #include "Buzzer.h"
    9          #include "MPU6050.h"
   10          
   11          extern float Exp_Speed;
   12          extern float Ratio;
   13          extern float ADC_proc[5];
   14          
   15          //上下坡标志位
   16          char Up_Down_Flag = 0;
   17          char delay_10ms = 0;
   18          
   19          //环岛标志位
   20          char circle_flag_L = 0;  // 左右环岛识别建立不同标志位
   21          char circle_flag_R = 0;
   22          char circle_In_Flag = 0;
   23          char circle_Out_Flag = 0;
   24          char circle_Force_Flag = 0;  //强迫出环标志位
   25          
   26          //避障相关标志位
   27          char Barrier_Flag1=0;
   28          char Barrier_Flag2=0;
   29          char Barrier_Flag3=0;
   30          char Barrier_Executed = 0;
   31          char Barrier_Flag4=0;
   32          char Avoid_ON = 0;
   33          float Sum_Angle=0;
   34          
   35          
   36          void Elem_Up_Down(float Angle,float Gyro)  //上下坡
   37          {
   38   1      
   39   1              if(Angle > -2 && Gyro > -400)
   40   1                      Exp_Speed = 310;
   41   1              else if(Angle < -15)
   42   1                      Exp_Speed = 30;
   43   1      }
   44          
   45          
   46          //障碍物识别     
   47          void Elem_Barrier(float Gyro_Z)
   48          {
   49   1              #if BARRIER_DIR == 0
   50   1                      //向右避障
   51   1                      Gyro_Z = (Gyro_Z*2000)/32768;   
   52   1                      if(Barrier_Flag1==1)
   53   1                      {
   54   2                              Ratio = -0.48 ;                 //直接更改期望值
   55   2                              Sum_Angle += Gyro_Z*0.005;
   56   2                              
   57   2                      }
C251 COMPILER V5.60.0,  Element                                                            13/03/24  22:32:50  PAGE 2   

   58   1                      if(Sum_Angle < -20)     //右拐避障
   59   1                      {
   60   2                              Ratio = -0.01;
   61   2                              Barrier_Flag1 = 0;   //出赛道角度停止积分
   62   2                              Barrier_Flag2 = 1;
   63   2                              Sum_Angle = 0;          //积分清零
   64   2                      }
   65   1                      if(Barrier_Flag2==1)
   66   1                      {
   67   2                              Sum_Angle += Gyro_Z*0.005;   
   68   2                              if(Sum_Angle < 22)  //左拐回正
   69   2                              {
   70   3                                      Ratio = 0.48;           
   71   3                              }
   72   2                              else
   73   2                                      Barrier_Flag3 = 1;  //回正
   74   2                      }
   75   1                      
   76   1                      if(Barrier_Flag3==1)            //回正后标志位清零
   77   1                      {       
   78   2                              Barrier_Flag1 = 0;
   79   2                              Barrier_Flag2 = 0;
   80   2                              Barrier_Flag3 = 0;
   81   2                              Sum_Angle = 0;
   82   2                              Barrier_Executed = 1;
   83   2                              Avoid_ON = 0;
   84   2                      }
   85   1              //      #if TRACE_METHOD2
   86   1              //              Barrier_Flag4 == 30;
   87   1              //      #endif
   88   1              #elif BARRIER_DIR == 1  //向左避障
                               Gyro_Z = (Gyro_Z*2000)/32768;   
                               if(Barrier_Flag1==1)
                               {
                                       Ratio = 0.48 ;                  //直接更改期望值
                                       Sum_Angle += Gyro_Z*0.005;
                                       
                               }
                               if(Sum_Angle > 20)      //左拐避障
                               {
                                       Ratio = 0.01;
                                       Barrier_Flag1 = 0;   //出赛道角度停止积分
                                       Barrier_Flag2 = 1;
                                       Sum_Angle = 0;          //积分清零
                               }
                               if(Barrier_Flag2==1)
                               {
                                       Sum_Angle += Gyro_Z*0.005;   
                                       if(Sum_Angle < -22)  //右拐回正
               
                                               Ratio = -0.48;          
                                       else
                                               Barrier_Flag3 = 1;  //回正
                               }
                               
                               if(Barrier_Flag3==1)            //回正后标志位清零
                               {       
                                       Barrier_Flag1 = 0;
                                       Barrier_Flag2 = 0;
                                       Barrier_Flag3 = 0;
                                       Sum_Angle = 0;
                                       Barrier_Executed = 1;
                                       Avoid_ON = 0;
                               }
                       #endif                          
  123   1      }
C251 COMPILER V5.60.0,  Element                                                            13/03/24  22:32:50  PAGE 3   

  124          
  125          //float Sum_Angle_C2 = 0;
  126          //进行右环岛识别并进出右环岛
  127          void Elem_Circle_R(float Speed,float Gyro_Z)
  128          {
  129   1              static float Sum_Dis1 = 0;
  130   1              static float Sum_Dis2 = 0;
  131   1              static float Sum_Angle_C1 = 0;
  132   1              static float Sum_Angle_C2 = 0;
  133   1              if(circle_flag_R == 1)  //识别圆环标志位
  134   1              {
  135   2                      Gyro_Z = (Gyro_Z*2000)/32768;
  136   2                      if(Sum_Dis1 > 3000) //路程积满入环，开始角度积分
  137   2                      {
  138   3                              if(Sum_Angle_C1 > -20) // 入环结束,正常循迹
  139   3                              {
  140   4                                      Ratio = -0.45;
  141   4                                      Sum_Angle_C1 += Gyro_Z*0.005;
  142   4                              }
  143   3                              else
  144   3                              {
  145   4                                      circle_In_Flag = 1;
  146   4                              }
  147   3                                              
  148   3                      }
  149   2                      else
  150   2                      {
  151   3                              Sum_Dis1 += Speed ;
  152   3                              Ratio = 0.09;
  153   3                      }
  154   2                              
  155   2                      if(circle_In_Flag == 1) //如果已经进环，判断出环条件，角度积满出环
  156   2                      {
  157   3                              if(Sum_Angle_C2 > ROUND_R) //右转角度积分是负值
  158   3                                      Sum_Angle_C2 += Gyro_Z*0.005;
  159   3                              else    
  160   3                                      circle_Out_Flag = 1;
  161   3                      }
  162   2                      if(circle_Out_Flag == 1)
  163   2                      {
  164   3                              Sum_Dis2 += Speed; //出环路程积分
  165   3                              if(Sum_Dis2 < 7000)
  166   3                                      Ratio += 0.33;
  167   3                              else                    //出环结束，标志位清零
  168   3                              {
  169   4                                      circle_flag_R = 0;
  170   4                                      Sum_Dis1 = 0;
  171   4                                      Sum_Dis2 = 0;
  172   4                                      Sum_Angle_C1 = 0;
  173   4                                      Sum_Angle_C2 = 0;
  174   4                                      circle_In_Flag = 0;
  175   4                                      circle_Out_Flag = 0;
  176   4                                      
  177   4                                      //实验室右环岛是最后一个特殊元素
  178   4                                      //如果有多个重复元素，再置一个记数标志位
  179   4                                      //Element_Num 
  180   4                                      //if(Element_Num == x) //重复元素全部走完
  181   4      //                              Avoid_ON == 1   
  182   4                                      
  183   4                              }
  184   3                      }
  185   2              }
  186   1              
  187   1      }
  188          
  189          //float Sum_Angle_C1 = 0;
C251 COMPILER V5.60.0,  Element                                                            13/03/24  22:32:50  PAGE 4   

  190          //进行左环岛识别并进出左环岛
  191          void Elem_Circle_L(float Speed,float Gyro_Z)
  192          {
  193   1              static float Sum_Dis1 = 0;
  194   1              static float Sum_Dis2 = 0;
  195   1              static float Sum_Angle_C1 = 0;
  196   1              static float Sum_Angle_C2 = 0;
  197   1              if(circle_flag_L == 1)  //识别圆环标志位
  198   1              {       
  199   2                      Gyro_Z = (Gyro_Z*2000)/32768;
  200   2                      if(Sum_Dis2>5000)
  201   2                      {
  202   3                              Sum_Angle_C1 += Gyro_Z*0.005;
  203   3                              if(Sum_Angle_C1<40)
  204   3                              {
  205   4                                      Ratio = 0.45;
  206   4                              }
  207   3                      }
  208   2                      else
  209   2                      {
  210   3                              Sum_Dis2+=Speed;
  211   3                      }
  212   2                      if(Sum_Angle_C1>120)
  213   2                      {
  214   3                              Sum_Dis1+=Speed;
  215   3                              if(Sum_Dis1>5000)
  216   3                              {
  217   4                                      x10_ms = 13;
  218   4                                      Ratio = 0.23;
  219   4                              }
  220   3                              else
  221   3                              {
  222   4                                      Sum_Dis1=0;
  223   4                                      Sum_Dis2=0;
  224   4                                      Sum_Angle_C1=0;
  225   4                                      circle_flag_L=0;
  226   4                              }
  227   3                      }
  228   2                      
  229   2      //              if(Sum_Dis1 > 3000 && Sum_Dis1 < 8000) //路程积满入环，开始角度积分
  230   2      //              {
  231   2      //                      x10_ms = 13;
  232   2      //                      if(Sum_Angle_C1 < 20) // 入环结束,正常循迹
  233   2      //                      {
  234   2      //                              Ratio = 0.45;
  235   2      //                              Sum_Angle_C1 += Gyro_Z*0.005;
  236   2      //                      }
  237   2      //                      else
  238   2      //                      {
  239   2      //                              circle_In_Flag = 1;     
  240   2      //                      }       
  241   2      //              }
  242   2      //              else if(Sum_Dis1 >6000  && Sum_Dis1 < 8000)
  243   2      //              {
  244   2      //                      Ratio = 0.12;
  245   2      //              }
  246   2      //              else if( Sum_Dis1 < 8000)
  247   2      //              {
  248   2      //                      Sum_Dis1 += Speed ;
  249   2      //              }
  250   2      //              
  251   2      //                      
  252   2      //              if(circle_In_Flag == 1) //如果已经进环，正常循迹
  253   2      //              {
  254   2      //                      if(Sum_Angle_C2 < ROUND_L) //判断出环条件，角度积满出环 左转角度积分是正值 
  255   2      //                              Sum_Angle_C2 += Gyro_Z*0.005;
C251 COMPILER V5.60.0,  Element                                                            13/03/24  22:32:50  PAGE 5   

  256   2      //                      else
  257   2      //                              circle_Out_Flag = 1;
  258   2      //              }
  259   2      //              if(circle_Out_Flag == 1)
  260   2      //              {
  261   2      //                      Sum_Dis2 += Speed; //出环路程积分
  262   2      //                      if(Sum_Dis2 < 7000)
  263   2      //                      {
  264   2      //                              Ratio -= 0.2;
  265   2      //                      }
  266   2      //                      else                    //出环结束，标志位清零
  267   2      //                      {
  268   2      //                              circle_flag_L = 0;
  269   2      //                              Sum_Dis1 = 0;
  270   2      //                              Sum_Dis2 = 0;
  271   2      //                              Sum_Angle_C1 = 0;
  272   2      //                              Sum_Angle_C2 = 0;
  273   2      //                              circle_In_Flag = 0;
  274   2      //                              circle_Out_Flag = 0;
  275   2      //                      }
  276   2      //              }
  277   2              }
  278   1      //      //如果误入环岛，也需要正常出去  ***********************************************************************
             -****/
  279   1      }
  280          
  281          
  282          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       754     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        49     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       137     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
