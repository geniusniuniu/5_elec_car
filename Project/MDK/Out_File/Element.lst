C251 COMPILER V5.60.0,  Element                                                            12/03/24  06:15:45  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Element
OBJECT MODULE PLACED IN .\Out_File\Element.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\Element.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\Element.lst) OBJECT(.\Out_File\Element.obj) 

stmt  level    source

    1          #include "isr.h"
    2          #include <string.h>
    3          #include <stdio.h>
    4          #include "common.h"
    5          #include "Element.h"
    6          #include "Motor.h"
    7          #include "PID.h"
    8          #include "Buzzer.h"
    9          #include "MPU6050.h"
   10          
   11          extern float Exp_Speed;
   12          extern float Ratio;
   13          extern float ADC_proc[5];
   14          
   15          //上下坡标志位
   16          char Up_Down_Flag = 0;
   17          char delay_10ms = 0;
   18          
   19          //环岛标志位
   20          char circle_flag_L = 0;  // 左右环岛识别建立不同标志位
   21          char circle_flag_R = 0;
   22          char circle_In_Flag = 0;
   23          char circle_Out_Flag = 0;
   24          char circle_Force_Flag = 0;  //强迫出环标志位
   25          
   26          //避障相关标志位
   27          char Barrier_Flag1=0;
   28          char Barrier_Flag2=0;
   29          char Barrier_Flag3=0;
   30          char Barrier_Executed = 0;
   31          char Barrier_Flag4=0;
   32          char Avoid_ON = 0;
   33          float Sum_Angle=0;
   34          
   35          
   36          void Elem_Up_Down(float Angle,float Gyro)  //上下坡
   37          {
   38   1      
   39   1              if(Angle > -2 && Gyro > -400)
   40   1                      Exp_Speed = 300;
   41   1              else if(Angle < -15)
   42   1                      Exp_Speed = 30;
   43   1      }
   44          
   45          
   46          //障碍物识别    
   47          void Elem_Barrier(float Gyro_Z)
   48          {
   49   1              Gyro_Z = (Gyro_Z*2000)/32768;   
   50   1              if(Barrier_Flag1==1)
   51   1              {
   52   2                      Ratio = -0.48 ;                 //直接更改期望值
   53   2                      Sum_Angle += Gyro_Z*0.005;
   54   2                      
   55   2              }
   56   1              if(Sum_Angle < -20)     //右拐避障
   57   1              {
C251 COMPILER V5.60.0,  Element                                                            12/03/24  06:15:45  PAGE 2   

   58   2                      //Ratio = 0.2;
   59   2                      Barrier_Flag1 = 0;   //出赛道角度停止积分
   60   2                      Barrier_Flag2 = 1;
   61   2                      Sum_Angle = 0;          //积分清零
   62   2              }
   63   1              if(Barrier_Flag2==1)
   64   1              {
   65   2                      Sum_Angle += Gyro_Z*0.005;   
   66   2                      if(Sum_Angle < 27)  //左拐回正
   67   2                      {
   68   3                              Ratio = 0.52;           
   69   3                              Barrier_Flag3 = 0;  //尚未回正
   70   3                      }
   71   2                      else
   72   2                              Barrier_Flag3 = 1;  //回正
   73   2               }
   74   1              
   75   1               if(Barrier_Flag3==1)           //回正后标志位清零
   76   1              {       
   77   2                      Barrier_Flag1 = 0;
   78   2                      Barrier_Flag2 = 0;
   79   2                      Barrier_Flag3 = 0;
   80   2                      Sum_Angle = 0;
   81   2                      Barrier_Executed = 1;
   82   2                      Avoid_ON = 0;
   83   2                      
   84   2      //      #if TRACE_METHOD2
   85   2      //              Barrier_Flag4 == 30;
   86   2      //      #endif
   87   2                                                      
   88   2              }
   89   1      }
   90          
   91          //进行右环岛识别并进出右环岛
   92          void Elem_Circle_R(float Speed,float Gyro_Z)
   93          {
   94   1              static float Sum_Dis1 = 0;
   95   1              static float Sum_Dis2 = 0;
   96   1              static float Sum_Angle_C1 = 0;
   97   1              static float Sum_Angle_C2 = 0;
   98   1              if(circle_flag_R == 1)  //识别圆环标志位
   99   1              {
  100   2                      Sum_Dis1 += Speed ;
  101   2                      if(Sum_Dis1 > 4000) //路程积满入环，开始角度积分
  102   2                      {
  103   3                              Gyro_Z = (Gyro_Z*2000)/32768;
  104   3                              if(Sum_Angle_C1 < -15) // 入环结束,正常循迹
  105   3                              {
  106   4                                      Ratio = -0.45;
  107   4                                      Sum_Angle_C1 += Gyro_Z*0.005;
  108   4                              }
  109   3                              else
  110   3                              {
  111   4                                      Sum_Angle_C1 = -21;
  112   4                                      circle_In_Flag = 1;
  113   4                              }
  114   3                                              
  115   3                      }
  116   2                      if(circle_In_Flag == 1) //如果已经进环，判断出环条件，角度积满出环
  117   2                      {
  118   3                              Gyro_Z = (Gyro_Z*2000)/32768;
  119   3                              
  120   3                              if(Sum_Angle_C2 > ROUND_R) //右转角度积分是负值
  121   3                                      Sum_Angle_C2 += Gyro_Z*0.005;
  122   3                              else    
  123   3                                      circle_Out_Flag = 1;
C251 COMPILER V5.60.0,  Element                                                            12/03/24  06:15:45  PAGE 3   

  124   3                      }
  125   2                      if(circle_Out_Flag == 1 && ADC_proc[2] > 70)
  126   2                      {
  127   3                              Sum_Dis2 += Speed; //出环路程积分
  128   3                              if(Sum_Dis2 < 5000)
  129   3                                      Ratio += 0.2;
  130   3                              else                    //出环结束，标志位清零
  131   3                              {
  132   4                                      circle_flag_R = 0;
  133   4                                      Sum_Dis1 = 0;
  134   4                                      Sum_Dis2 = 0;
  135   4                                      Sum_Angle_C1 = 0;
  136   4                                      Sum_Angle_C2 = 0;
  137   4                                      circle_In_Flag = 0;
  138   4                                      circle_Out_Flag = 0;
  139   4                                      
  140   4                                      //实验室右环岛是最后一个特殊元素
  141   4                                      //如果有多个重复元素，再置一个记数标志位
  142   4                                      //Element_Num 
  143   4                                      //if(Element_Num == x) //重复元素全部走完
  144   4      //                              Avoid_ON == 1   
  145   4                                      
  146   4                              }
  147   3                      }
  148   2              }
  149   1              
  150   1      }
  151          
  152          
  153          //进行左环岛识别并进出左环岛
  154          void Elem_Circle_L(float Speed,float Gyro_Z)
  155          {
  156   1              static float Sum_Dis1 = 0;
  157   1              static float Sum_Dis2 = 0;
  158   1              static float Sum_Angle_C1 = 0;
  159   1              static float Sum_Angle_C2 = 0;
  160   1              if(circle_flag_L == 1)  //识别圆环标志位
  161   1              {               
  162   2                      Sum_Dis1 += Speed ;
  163   2                      if(Sum_Dis1 > 4000) //路程积满入环，开始角度积分
  164   2                      {
  165   3                              Gyro_Z = (Gyro_Z*2000)/32768;
  166   3                              if(Sum_Angle_C1 < 15) // 入环结束,正常循迹
  167   3                              {
  168   4                                      Ratio = 0.45;
  169   4                                      Sum_Angle_C1 += Gyro_Z*0.005;
  170   4                              }
  171   3                              else
  172   3                              {
  173   4                                      Sum_Angle_C1 = 21;
  174   4                                      circle_In_Flag = 1;     
  175   4                              }
  176   3                                      
  177   3                      }
  178   2                      if(circle_In_Flag == 1) //如果已经进环，正常循迹
  179   2                      {
  180   3                              Gyro_Z = (Gyro_Z*2000)/32768;
  181   3                              
  182   3                              if(Sum_Angle_C2 < ROUND_L) //判断出环条件，角度积满出环 左转角度积分是正值 
  183   3                                      Sum_Angle_C2 += Gyro_Z*0.005;
  184   3                              else
  185   3                                      circle_Out_Flag = 1;
  186   3                      }
  187   2                      if(circle_Out_Flag == 1 && ADC_proc[2] > 70)
  188   2                      {
  189   3                              Sum_Dis2 += Speed; //出环路程积分
C251 COMPILER V5.60.0,  Element                                                            12/03/24  06:15:45  PAGE 4   

  190   3                              if(Sum_Dis2 < 5000)
  191   3                              {
  192   4                                      Ratio -= 0.2;
  193   4                              }
  194   3                              else                    //出环结束，标志位清零
  195   3                              {
  196   4                                      circle_flag_L = 0;
  197   4                                      Sum_Dis1 = 0;
  198   4                                      Sum_Dis2 = 0;
  199   4                                      Sum_Angle_C1 = 0;
  200   4                                      Sum_Angle_C2 = 0;
  201   4                                      circle_In_Flag = 0;
  202   4                                      circle_Out_Flag = 0;
  203   4                              }
  204   3                      }
  205   2              }
  206   1      //      //如果误入环岛，也需要正常出去  ***********************************************************************
             -****/
  207   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       890     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        49     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       137     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
