C251 COMPILER V5.60.0,  Element                                                            24/03/24  22:28:30  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Element
OBJECT MODULE PLACED IN .\Out_File\Element.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\CODE\Element.c XSMALL INTR2 WARNINGLEVEL(3) BR
                    -OWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\
                    -USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\Element.lst) OBJECT(.\Out_File\Element.obj) 

stmt  level    source

    1          #include "isr.h"
    2          #include <string.h>
    3          #include <stdio.h>
    4          #include "common.h"
    5          #include "Element.h"
    6          #include "Motor.h"
    7          #include "PID.h"
    8          #include "Buzzer.h"
    9          #include "MPU6050.h"
   10          
   11          extern float Exp_Speed;
   12          extern float Ratio;
   13          extern float ADC_proc[5];
   14          
   15          //上下坡标志位
   16          char Up_Down_Flag = 0;
   17          char delay_10ms = 0;
   18          
   19          //环岛标志位
   20          float Circle_Flag = 0;  // 左右环岛标志位
   21          char Circle_Flag2 = 0;
   22          char Circle_Flag3 = 0;
   23          //避障相关标志位
   24          char Barrier_Flag1=0;
   25          char Barrier_Flag2=0;
   26          char Barrier_Flag3=0;
   27          char Barrier_Executed = 0;
   28          char Barrier_Flag4=0;
   29          char Avoid_ON = 0;
   30          float Sum_Angle=0;
   31          
   32          
   33          void Elem_Up_Down(float Angle,float Gyro)  //上下坡
   34          {
   35   1      
   36   1              if(Angle > -4 && Gyro < -400)
   37   1                      Exp_Speed = 350;
   38   1              else if(Angle < -18)
   39   1                      Exp_Speed = 30;
   40   1      }
   41          
   42          
   43          //障碍物识别     
   44          void Elem_Barrier(float Gyro_Z)
   45          {
   46   1              #if BARRIER_DIR == 0
                               //向右避障
                               Gyro_Z = (Gyro_Z*2000)/32768;   
                               if(Barrier_Flag1==1)
                               {
                                       Ratio = -0.48 ;                 //直接更改期望值
                                       Sum_Angle += Gyro_Z*0.005;
                                       
                               }
                               if(Sum_Angle < -20)     //右拐避障
                               {
                                       Ratio = -0.01;
C251 COMPILER V5.60.0,  Element                                                            24/03/24  22:28:30  PAGE 2   

                                       Barrier_Flag1 = 0;   //出赛道角度停止积分
                                       Barrier_Flag2 = 1;
                                       Sum_Angle = 0;          //积分清零
                               }
                               if(Barrier_Flag2==1)
                               {
                                       Sum_Angle += Gyro_Z*0.005;   
                                       if(Sum_Angle < 22)  //左拐回正
                                       {
                                               Ratio = 0.48;           
                                       }
                                       else
                                               Barrier_Flag3 = 1;  //回正
                               }
                               
                               if(Barrier_Flag3==1)            //回正后标志位清零
                               {       
                                       Barrier_Flag1 = 0;
                                       Barrier_Flag2 = 0;
                                       Barrier_Flag3 = 0;
                                       Sum_Angle = 0;
                                       Barrier_Executed = 1;
                                       Avoid_ON = 0;
                               }
                       //      #if TRACE_METHOD2
                       //              Barrier_Flag4 == 30;
                       //      #endif
                       #elif BARRIER_DIR == 1  //向左避障
   86   1                      Gyro_Z = (Gyro_Z*2000)/32768;   
   87   1                      if(Barrier_Flag1==1)
   88   1                      {
   89   2                              Ratio = 0.48;                   //直接更改期望值
   90   2                              Sum_Angle += Gyro_Z*0.005;
   91   2                              
   92   2                      }
   93   1                      if(Sum_Angle > 20)      //左拐避障
   94   1                      {
   95   2                              Ratio = 0.01;
   96   2                              Barrier_Flag1 = 0;   //出赛道角度停止积分
   97   2                              Barrier_Flag2 = 1;
   98   2                              Sum_Angle = 0;          //积分清零
   99   2                      }
  100   1                      if(Barrier_Flag2==1)
  101   1                      {
  102   2                              Sum_Angle += Gyro_Z*0.005;   
  103   2                              if(Sum_Angle < -22)  //右拐回正
  104   2      
  105   2                                      Ratio = -0.48;          
  106   2                              else
  107   2                                      Barrier_Flag3 = 1;  //回正
  108   2                      }
  109   1                      
  110   1                      if(Barrier_Flag3==1)            //回正后标志位清零
  111   1                      {       
  112   2                              Barrier_Flag1 = 0;
  113   2                              Barrier_Flag2 = 0;
  114   2                              Barrier_Flag3 = 0;
  115   2                              Sum_Angle = 0;
  116   2                              Barrier_Executed = 1;
  117   2                              Avoid_ON = 0;
  118   2                      }
  119   1              #endif                          
  120   1      }
  121          
  122          
  123          float Sum_Dis1 = 0;
C251 COMPILER V5.60.0,  Element                                                            24/03/24  22:28:30  PAGE 3   

  124          float Sum_Dis2 = 0;
  125          float Sum_Angle_C1 = 0;
  126          void Elem_Circle(float Speed,float Gyro_Z)
  127          {
  128   1      //      static float Sum_Dis1 = 0;
  129   1      //      static float Sum_Dis2 = 0;
  130   1      //      static float Sum_Angle_C1 = 0;
  131   1              static float Delay_10Ms = 0;
  132   1              if(Delay_10Ms > 0)
  133   1              {
  134   2                      Circle_Flag = 0;
  135   2                      Circle_Flag2 = 0;
  136   2                      if(Circle_Flag3 == LEFT_CIRCLE)
  137   2                              Ratio -=0.2;
  138   2                      else if(Circle_Flag3 == RIGHT_CIRCLE)
  139   2                              Ratio +=0.2;
  140   2                      Delay_10Ms--;
  141   2                      return ;        //发生误判，退出函数
  142   2              }
  143   1              else
  144   1                      Circle_Flag3 = 0;
  145   1              if(Circle_Flag2)
  146   1              {
  147   2                      x10_ms = 13;
  148   2                      Gyro_Z = (Gyro_Z*2000)/32768;
  149   2                      if(Sum_Dis1>DIS_ROUND_IN)
  150   2                      {
  151   3                              Sum_Angle_C1 += Gyro_Z*0.005;
  152   3                              if(Circle_Flag == 0 && (ADC_proc[0]+ADC_proc[1] > ADC_proc[3]+ADC_proc[4]))
  153   3                                      Circle_Flag = LEFT_CIRCLE;
  154   3                              else if(Circle_Flag == 0 && (ADC_proc[0]+ADC_proc[1] < ADC_proc[3]+ADC_proc[4]))
  155   3                                      Circle_Flag = RIGHT_CIRCLE;
  156   3                              Circle_Flag3 = Circle_Flag;
  157   3                              if(Sum_Angle_C1 < 30  && Circle_Flag == LEFT_CIRCLE)
  158   3                                      Ratio = 0.52;
  159   3                              if(Sum_Angle_C1 > -30 && Circle_Flag == RIGHT_CIRCLE)
  160   3                                      Ratio = -0.52;
  161   3                      }
  162   2                      else
  163   2                              Sum_Dis1+=Speed;
  164   2                      
  165   2                      if(Sum_Angle_C1 > ROUND_L || Sum_Angle_C1 < ROUND_R )
  166   2                      {
  167   3                              if(ADC_proc[2] > 64 || ADC_proc[0] > 59 || ADC_proc[4] > 59)   //预出环 防止误判入环
  168   3                              {
  169   4                                      Sum_Dis2 += Speed;
  170   4                                      if(Sum_Dis2 > DIS_ROUND_OUT)
  171   4                                      {
  172   5                                              Sum_Dis1 = 0;
  173   5                                              Sum_Dis2 = 0;
  174   5                                              Sum_Angle_C1 = 0;
  175   5                                              Circle_Flag = 0;
  176   5                                              Circle_Flag2 = 0;
  177   5                                      }
  178   4                                      Delay_10Ms = 60;   //延时1500ms
  179   4                              }
  180   3                      }
  181   2              }
  182   1              else
  183   1              {
  184   2                      Sum_Dis1 = 0;
  185   2                      Sum_Dis2 = 0;
  186   2                      Sum_Angle_C1 = 0;
  187   2                      Circle_Flag = 0;
  188   2              }
  189   1      }
C251 COMPILER V5.60.0,  Element                                                            24/03/24  22:28:30  PAGE 4   

  190          
  191          
  192          
  193          ////进行左环岛识别并进出左环岛
  194          //void Elem_Circle_L(float Speed,float Gyro_Z)
  195          //{
  196          //      static float Sum_Dis1 = 0;
  197          //      static float Sum_Dis2 = 0;
  198          //      static float Sum_Angle_C1 = 0;
  199          //      static char Delay_10Ms = 0;
  200          //      if(Delay_10Ms > 0)
  201          //      {
  202          //              circle_flag_L = 0;
  203          //              circle_flag_R = 0;
  204          //              Ratio -= 0.2;
  205          //              Delay_10Ms --;
  206          //              return;        //发生误判，强制退出
  207          //      }
  208          
  209          //      if(circle_flag_L == 1)  //识别圆环标志位
  210          //      {       
  211          //              Gyro_Z = (Gyro_Z*2000)/32768;
  212          //              if(Sum_Dis2>DIS_ROUND_IN)
  213          //              {
  214          //                      Sum_Angle_C1 += Gyro_Z*0.005;
  215          //                      if(Sum_Angle_C1 < 80)
  216          //                              Ratio = 0.52;
  217          //              }
  218          //              else
  219          //                      Sum_Dis2+=Speed;
  220          //              if(Sum_Angle_C1 > ROUND_L)
  221          //              {
  222          //                      if(ADC_proc[2] > 66)   //预出环 防止再次误判
  223          //                      {
  224          //                              Sum_Dis1 += Speed;
  225          //                              if(Sum_Dis1 > DIS_ROUND_OUT)
  226          //                              {
  227          //                                      Sum_Dis1=0;
  228          //                                      Sum_Dis2=0;
  229          //                                      Sum_Angle_C1=0;
  230          //                                      circle_flag_R=0;
  231          //                              }
  232          //                              Delay_10Ms = 100;   //延时1000ms
  233          //                      }
  234          //              }
  235          //              
  236          //                              //实验室右环岛是最后一个特殊元素
  237          //                              //如果有多个重复元素，再置一个记数标志位
  238          //                              //Element_Num 
  239          //                              //if(Element_Num == x) //重复元素全部走完
  240          ////                            Avoid_ON == 1   
  241          //              
  242          ////如果误入环岛，也需要正常出去        ************************************************************************
             -***/
  243          //      }
  244          //}
  245          
  246          
  247          
  248          //float Sum_Dis1 = 0;
  249          //float Sum_Dis2 = 0;
  250          //float Sum_Angle_C1 = 0;
  251          ////进行右环岛识别并进出右环岛
  252          //void Elem_Circle_R(float Speed,float Gyro_Z)
  253          //{
  254          ////    static float Sum_Dis1 = 0;
C251 COMPILER V5.60.0,  Element                                                            24/03/24  22:28:30  PAGE 5   

  255          ////    static float Sum_Dis2 = 0;
  256          ////    static float Sum_Angle_C1 = 0;
  257          //      static char Delay_10Ms = 0;
  258          //      if(Delay_10Ms > 0)
  259          //      {
  260          //              circle_flag_R = 0;
  261          //              circle_flag_L = 0;
  262          //              Ratio += 0.2;
  263          //              Delay_10Ms--;
  264          //              return;
  265          //      }
  266          //      if(circle_flag_R == 1)  //识别圆环标志位
  267          //      {       
  268          //              Gyro_Z = (Gyro_Z*2000)/32768;
  269          //              if(Sum_Dis2>DIS_ROUND_IN)
  270          //              {
  271          //                      Sum_Angle_C1 += Gyro_Z*0.005;
  272          //                      if(Sum_Angle_C1 > -80)
  273          //                              Ratio = -0.52;
  274          //              }
  275          //              else
  276          //                      Sum_Dis2 += Speed;
  277          //              if(Sum_Angle_C1 < ROUND_R)
  278                  //      {
  279                  //              if(ADC_proc[2] > 66)   //预出环 防止再次误判
  280                  //              {
  281                  //                      Sum_Dis1 += Speed;
  282                  //                      if(Sum_Dis1 > DIS_ROUND_OUT)
  283                  //                      {
  284                  //                              Sum_Dis1=0;
  285                  //                              Sum_Dis2=0;
  286                  //                              Sum_Angle_C1=0;
  287                  //                              circle_flag_R=0;
  288                  //                      }
  289                  //                      Delay_10Ms = 100;   //延时1000ms
  290                  //              }
  291          //              }
  292          //      }
  293          //}
  294          
  295          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       806     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        34     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        98     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
