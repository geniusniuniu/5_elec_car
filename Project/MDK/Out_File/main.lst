C251 COMPILER V5.60.0,  main                                                               03/03/24  23:10:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\Out_File\main.obj
COMPILER INVOKED BY: D:\keil5\keil5_MDK\keil5_MDK_32\C251\BIN\C251.EXE ..\USER\src\main.c XSMALL INTR2 WARNINGLEVEL(3) B
                    -ROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..
                    -\USER\inc;..\USER\src) DEBUG PRINT(.\Out_File\main.lst) OBJECT(.\Out_File\main.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          #include "Motor.h"
    3          #include "ADC.h"
    4          #include "MPU6050.h"
    5          #include "Element.h"
    6          #include "ADC.h"
    7          #include "math.h"
    8          #include "TOF.h"
    9          #include "Buzzer.h"
   10          #include "Key.h"
   11          #include "ui.h"
   12          
   13          extern uint16 vl53l0x_distance_mm;
   14          extern uint8 vl53l0x_finsh_flag;
   15          
   16          short gx, gy, gz;
   17          char Isr_flag_10 = 0; 
   18          
   19          char KeyValue = 0;
   20          
   21          float Diff,Plus;
   22          float Ratio = 0;
   23          
   24          float Diff_Mid,Plus_Mid;
   25          float Ratio_Mid = 0;
   26          float sum;
   27          int dis = 2000;
   28          
   29          float Exp_Speed_L = 0;
   30          float Exp_Speed_R = 0;
   31          float Exp_Speed = 200;
   32          
   33          void Init_all(void);
   34          void Get_Ratio(void);
   35          
   36          //void OLED_Printf(void)
   37          //{
   38          //      oled_printf_float(0,0,ADC_proc[0],5,2);
   39          //      oled_printf_float(0,2,ADC_proc[1],5,2);
   40          //      oled_printf_float(0,0,KeyAdjust_PID,5,2);
   41          //      oled_printf_float(0,2,Exp_Speed,5,2);
   42          //      oled_printf_float(0,4,ADC_proc[2],5,2);
   43          //      oled_printf_float(0,6,ADC_proc[3],5,2);
   44          //      oled_printf_float(60,0,ADC_proc[4],5,2);
   45          //      
   46          //      oled_printf_float(60,2,vl53l0x_distance_mm,5,2);
   47          //      oled_printf_float(60,4,Ratio,1,2);
   48          //}
   49          
   50          void main(void) 
   51          {
   52   1              Init_all();
   53   1              EnableGlobalIRQ();      
   54   1              while(1)
   55   1              {               
   56   2      //              printf("%.2f,%.2f,%.2f,%.2f,%.2f\r\n",Exp_Speed_L,Exp_Speed_R,Speed_L,Speed_R,Turn_PID.PID_Out*0.09);
   57   2      //              printf("%.2f,%.2f,%.2f,%.2f,%.2f,%.2f\r\n",ADC_proc[0],ADC_proc[1],Sum_Angle,sum_L,sum_R,Ratio);
C251 COMPILER V5.60.0,  main                                                               03/03/24  23:10:29  PAGE 2   

   58   2                      
   59   2      /******************************************** 按键读值***********************************************
             -***********************/       
   60   2              Adjust_Mode();
   61   2              if (Mode == 1)          //显示模式
   62   2              {
   63   3                      ui_show();
   64   3                      KeyValue = GetKey_Value(0);
   65   3                      if (KeyValue == KEY2_PRES)              {page++; oled_all_static_state();}              
   66   3                      else if (KeyValue == KEY3_PRES) {page--; oled_all_static_state();}      
   67   3                      if(page >= 3)  page = 0;
   68   3                      if(page < 0)   page = 2;
   69   3              }
   70   2              else if (Mode == 0) //调参模式
   71   2      //      {
   72   2                      oled_fill(0x00);  //初始清屏
   73   2                      KeyValue = GetKey_Value(0);
   74   2      //              if (KeyValue == KEY1_PRES) 
   75   2      //                      Turn_PID.Kp += 1;
   76   2      //              else if (KeyValue == KEY2_PRES) 
   77   2      //                      Turn_PID.Kp -= 1;
   78   2      //      } 
   79   2      //      else 
   80   2      //              Mode = 1; // 默认为显示模式
   81   2                      
   82   2      /******************************************** 类似中断服务处理 **********************************
             -****************************/ 
   83   2                      if(Isr_flag_10 == 1)  
   84   2                      {
   85   3                              ADC_GetValue();
   86   3                              MPU6050_Refresh_DMP();
   87   3                              MPU_Get_Gyroscope(&gx, &gy, &gz);
   88   3                              Get_Ratio();
   89   3                              
   90   3                      /************************************************ 直道弯道判别 **********************************
             -**********/ 
   91   3                              if(Ratio > -0.1 && Ratio < 0.1) //直线
   92   3                              {
   93   4                                      Turn_PID.Kp = -20;
   94   4                                      Turn_PID.Kd = -3.5;
   95   4                                      Left_Wheel_PID.Kp = Right_Wheel_PID.Kp = 20;
   96   4                                      Left_Wheel_PID.Ki = Right_Wheel_PID.Ki = 0.6;
   97   4                                      //Exp_Speed = 220;
   98   4                              }
   99   3                              else   // 拐弯
  100   3                              {
  101   4                                      Turn_PID.Kp = -180;
  102   4                                      Turn_PID.Kd = -32;
  103   4                                      Left_Wheel_PID.Kp = Right_Wheel_PID.Kp = 28;
  104   4                                      Left_Wheel_PID.Ki = Right_Wheel_PID.Ki = 1.28; //i太大会出现矫正滞后，导致车反方向飘
             -逸
  105   4                                      Exp_Speed -= 40;
  106   4                              }
  107   3                              
  108   3                      /************************************************ 避开路障 ****************************************
             -*******/                         
  109   3                              if(Barrier_Flag4 == 0) //确保避障只运行一次
  110   3                              {
  111   4                                      vl53l0x_get_distance();
  112   4                                      if(vl53l0x_finsh_flag)  //一次测距完成
  113   4                                      {
  114   5                                              if (vl53l0x_distance_mm < 600)          //      检测到路障
  115   5                                              {
  116   6                                                      x10_ms = 13;  
  117   6                                                      Barrier_Flag1 = 1;
  118   6                                              }
C251 COMPILER V5.60.0,  main                                                               03/03/24  23:10:29  PAGE 3   

  119   5                                      }
  120   4                                      Elem_Barrier(gz);
  121   4                              }
  122   3                              
  123   3                      /************************************************ 圆环判别 ****************************************
             -*******/ 
  124   3                              if(ADC_proc[2] > 75 && (ADC_proc[3] > 8 || ADC_proc[1] > 8))    //中间横电感识别圆环
  125   3                              {
  126   4                                      x10_ms = 13; 
  127   4                                      if(ADC_proc[3] > ADC_proc[1])  //判断左右
  128   4                                      {
  129   5                                              circle_flag_R = 1;
  130   5                                              Elem_Circle_R((Speed_L + Speed_R)/2,gz);        
  131   5                                      }
  132   4                                      else if(ADC_proc[3] < ADC_proc[1]) 
  133   4                                      {
  134   5                                              circle_flag_L = 1;
  135   5                                              Elem_Circle_L((Speed_L + Speed_R)/2,gz);
  136   5                                      }
  137   4                              }
  138   3                                      
  139   3                      /************************************************ 转向环计算 *************************************
             -*********/                         
  140   3                              PID_Calculate(&Turn_PID,Ratio*100,gz/100); 
  141   3                              Limit_Out(&Turn_PID.PID_Out,-2000,5000);
  142   3                                      
  143   3                      /************************************************ 上下坡道 ****************************************
             -********/ 
  144   3                              Elem_Up_Down(Pitch,gy);         
  145   3                                      
  146   3                      /************************************************ 特殊元素降速 **********************************
             -**********/ 
  147   3                              if( circle_flag_L == 1 || circle_flag_R == 1 || Barrier_Flag2 == 1 || Barrier_Flag1 == 1)  
  148   3                                      //Exp_Speed = 160;
  149   3                              Exp_Speed_L = Exp_Speed + Turn_PID.PID_Out*0.09;
  150   3                              Exp_Speed_R = Exp_Speed - Turn_PID.PID_Out*0.09;
  151   3                              
  152   3                              Get_Speed();  //获取车速
  153   3      
  154   3                              PID_Calculate(&Left_Wheel_PID,Exp_Speed_L,Speed_L);//速度环PID计算
  155   3                              PID_Calculate(&Right_Wheel_PID,Exp_Speed_R,Speed_R);
  156   3                              
  157   3                 /********************************************* 驶离赛道，停车 ********************************
             -*************/ 
  158   3                              if(ADC_proc[2]<5 && Barrier_Executed == 1) 
  159   3                              {
  160   4                                      Left_Wheel_PID.PID_Out = 0;
  161   4                                      Right_Wheel_PID.PID_Out = 0;
  162   4                              }
  163   3                              
  164   3                              Left_SetSpeed(Left_Wheel_PID.PID_Out);
  165   3                              Right_SetSpeed(Right_Wheel_PID.PID_Out);
  166   3      
  167   3      //                      Left_SetSpeed(2000);
  168   3      //                      Right_SetSpeed(-4000);
  169   3                              Isr_flag_10 = 0;
  170   3                      } 
  171   2              }
  172   1      }
  173          
  174          void Init_all(void)
  175          {
  176   1              WTST = 0;                                               //���ó������ȴ���������ֵΪ0�ɽ�CPUִ�г��
             -���ٶ�����Ϊ���  
  177   1              DisableGlobalIRQ();                             //�ر����ж�
  178   1              sys_clk = 35000000;                             //����ϵͳƵ��Ϊ35MHz
C251 COMPILER V5.60.0,  main                                                               03/03/24  23:10:29  PAGE 4   

  179   1      
  180   1      //��ʼ���Ĵ���
  181   1              board_init();                                   
  182   1      
  183   1      ////编码器方向引脚初始化
  184   1              gpio_mode(P5_3, GPIO);          
  185   1              gpio_mode(P3_5, GPIO);  
  186   1              
  187   1      ////按键引脚初始化
  188   1              Key_Init();
  189   1              
  190   1      ////测距模块初始化
  191   1              //gpio_mode(P3_2, GPIO);
  192   1      //      vl53l0x_init();
  193   1              
  194   1      ////OLED初始化
  195   1              ui_init();                                      
  196   1              
  197   1      ////MPU6050初始化
  198   1              MPU6050_DMP_Init();     
  199   1      //      
  200   1      ////定时器初始化
  201   1              pit_timer_ms(TIM_4, 10);                //10ms定时器
  202   1      //      
  203   1      ////编码器初始化
  204   1              ctimer_count_init(CTIM0_P34);   //编码器1计数
  205   1              ctimer_count_init(CTIM3_P04);   //编码器2计数
  206   1              
  207   1      ////串口初始化
  208   1      //      uart_init(UART_1, UART1_RX_P30, UART1_TX_P31, 115200, TIM_2);
  209   1              
  210   1      ////电机初始化
  211   1              Motor_Init();
  212   1              
  213   1      ////蜂鸣器初始化
  214   1              //Buzzer_Init();
  215   1              
  216   1      ////初始化所有AD引脚
  217   1              ADC_InitAll(); 
  218   1              
  219   1      ////pid初始化  PID_Init(结构体, KP, KI, KD, 输出限幅，积分限幅)
  220   1              PID_Init(&Left_Wheel_PID , 20, 0.5, 0, 10000, 2000);
  221   1              PID_Init(&Right_Wheel_PID, 20, 0.5, 0, 10000, 2000);
  222   1              PID_Init(&Turn_PID , -2, 0, 0 ,10000, 0);
  223   1      } 
  224          
  225          //对ADC值进行处理得到差比和
  226          void Get_Ratio(void)
  227          {
  228   1              sum = ADC_proc[0]+ ADC_proc[1]+ADC_proc[4]+ADC_proc[3];
  229   1      //      sum_L = sqrt((ADC_proc[0]*ADC_proc[0]+ADC_proc[1]*ADC_proc[1]));
  230   1      //      sum_R = sqrt((ADC_proc[2]*ADC_proc[2]+ADC_proc[3]*ADC_proc[3]));
  231   1      
  232   1              Diff = ADC_proc[0] - ADC_proc[4];
  233   1              Plus = ADC_proc[0] + ADC_proc[4];
  234   1              
  235   1              Diff_Mid = ADC_proc[1] - ADC_proc[3];
  236   1              Plus_Mid = ADC_proc[1] + ADC_proc[3];
  237   1              
  238   1              if(sum > 20)  //边界保护
  239   1              {
  240   2                      Ratio = Diff/Plus;
  241   2                      Ratio_Mid = Diff_Mid/Plus_Mid;
  242   2                      if(Plus_Mid > 30 && Plus_Mid < 65)
  243   2                      {
  244   3                              Ratio = Ratio_Mid;
C251 COMPILER V5.60.0,  main                                                               03/03/24  23:10:29  PAGE 5   

  245   3                      }
  246   2              }
  247   1      
  248   1      }
  249          
  250          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1159     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        50     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        56     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
